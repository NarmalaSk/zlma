#!/bin/bash
#
# instzlma - install zlma onto a Linux on s390x (mainframe) architecture 
#            user running this must have sudo access
#
#+--------------------------------------------------------------------------+
function usage()
# Give help to the user
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  echo "instzlma - install zlma onto s390x Linux" 
  echo "Usage: instzlma [OPTIONS]" 
  echo ""
  echo "OPTIONS:"
  echo "  -h|--help         Give help (this screen)"
  echo "  -p|--python PYTHON_CMD Where PYTHON_CMD is the python level to use (ex: python3.11)"
  echo "  -v|--verbose      Increase verbosity"
  echo "  -x|--debug        Print commands and arguments as they are executed"
  echo ""
  exit 51
 }                                         # usage()

#+--------------------------------------------------------------------------+
function parseArgs()
# Parse arguments
# Args: All arguments passed into script
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  while [ -n "$1" ]                        # loop through args passed in
  do
    case "$1" in
      -h|--help)
        usage
        ;;
      -p|--python)
        shift
        if [ $# = 0 ]; then                # PYTHON_CMD not supplied
          echo "ERROR: PYTHON_CMD not supplied"
          usage
        fi 
        flags="-v"
        pythonCmd=$1
        which $pythonCmd >/dev/null 2>&1
        if [ $? != 0 ]; then               # command not found
          echo "ERROR: $pythonCmd not found"
          usage
        fi
        ;;
      -v|--verbose)
        verbose=2
        flags="-v"
        ;;
      -x|--debug)                          # turn trace on
         set -vx
         ;;
      *)
        echo "ERROR: Too many arguments: $1"
        usage
        ;;
    esac
    shift
  done
 }                                         # parseArgs()

#+--------------------------------------------------------------------------+
function checkBase
# Check that:
# - We are running on s390x (zLinux) 
# - The zlma repo is cloned
# - Either 'apache' or 'www-data' user exists
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  if [ ! -f /proc/sysinfo ]; then          # not zLinux
    echo "ERROR: /proc/sysinfo not found - not running on s390x?" 
    exit 1
  fi
  if [ ! -d $HOME/zlma ]; then
    echo 'ERROR: zlma repo not found under $HOME' 
    echo "Try:   cd; git clone https://github.com/mike99mac/zlma"
    exit 2
  fi
  id apache > /dev/null 2>&1
  if [ $? = 0 ]; then                      # user exists - assume RHEL-based
    webUser="apache"
    webDir="/var/log/httpd"
  else
    id www-data > /dev/null 2>&1
    if [ $? = 0 ]; then                    # user exists - assume Debian-based
      webUser="www-data"
      webDir="/var/log/apache2"
    else
      echo "ERROR: neither user 'apache' nor 'www-data' found - exiting" 
      exit 3
    fi
  fi
 }                                         # checkBase()

#+--------------------------------------------------------------------------+
function verboseMsg
# Write message to stdout when -v|--verbose is set 
# Args: message to write
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  if [ "$verbose" -gt 1 ]; then            # verbose 
    echo -e "$@"
  fi
 }                                         # verboseMsg()

#+--------------------------------------------------------------------------+
function runCmd
# Run a command and exit if it fails
# Args: command to run
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  cmd="$@"                                 # all args

  echo "  Running: $cmd" | tee -a $outFile
  eval $cmd 2>&1 
  rc=$?
  if [ "$rc" != 0 ]; then                  # it failed
    echo "ERROR: $cmd returned $rc - exiting" 
    exit 4
  fi
 }                                         # runCmd()

#+--------------------------------------------------------------------------+
function mkDir
# Make specified directory, set owner and group to webUser, set group write bit 
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local theDir=$1
  local rc
  
  if [ -d $theDir ]; then                  # directory exists
    echo "  directory $theDir already exists"
  else                                     # create directory and set attributes
    runCmd sudo mkdir -p $theDir
    runCmd sudo chown $webUser.$webUser $theDir
    runCmd sudo chmod g+w $theDir
  fi 
 }                                         # mkDir

#+--------------------------------------------------------------------------+
function copyAllFiles 
# Copy all files from repo directories to new ones
# Arg 1: source dir
# Arg 2: target dir
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local sourceDir=$1
  local targetDir=$2

  if [ ! -d $theDir ]; then                  # directory exists
    echo "ERROR: Unexpected - source directory $sourceDir does not exist - exiting"
    exit 5
  fi
  runCmd cd $sourceDir
  runCmd "sudo cp * $targetDir"
  runCmd cd $targetDir
  runCmd "sudo chown $webUser.$webUser *"
 }                                         # mkDir()

#+--------------------------------------------------------------------------+
function copyOneFile
# Copy one file and set ownership to webUser
# Arg 1: source dir
# Arg 2: source file
# Arg 3: target dir
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local sourceDir=$1
  local sourceFile=$2
  local targetDir=$3

  runCmd sudo cp $sourceDir/$sourceFile $targetDir
  runCmd sudo chown $webUser.$webUser $targetDir/$sourceFile
 }                                         # copyOneFile()

#+--------------------------------------------------------------------------+
function instPackages
# Install packages with either 'apt' or 'dnf' 
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local cmd

  echo; echo "Step 1): Installing packages ..." | tee -a $outFile | tee -a $outFile

  which apt >/dev/null 2>&1
  if [ $? = 0 ]; then                      # use apt and assume Debian-based
    cmd="sudo apt install -y cifs-utils cmake curl gcc git make mariadb-server mlocate net-tools pandoc python3 python3-dev python3-pip"
    runCmd $cmd

    echo; echo "Step 2): Setting Apache and mariadb to start at boot time ..." | tee -a $outFile

    runCmd sudo systemctl enable apache2   # set Apache to start at boot
  else                                     # no apt, check for dnf
    which dnf >/dev/null 2>&1
    if [ $? = 0 ]; then                    # use dnf and assume RHEL-based
      cmd="sudo dnf install -y bzip2-devel cifs-utils curl gcc git libffi-devel make mariadb-connector-c mariadb-connector-c-devel.s390x mariadb-server mlocate net-tools openssl-devel python3 python3-pip tar" 
      local morePkgs="python3 python3-devel python3-pip vim wget zlib-devel"
      runCmd $cmd $morePkgs

      echo; echo "Step 2): Setting Apache and mariadb to start at boot time ..." | tee -a $outFile

      sudo systemctl enable httpd          # set Apache to start at boot - ignore non-0 rc
    else

      echo "ERROR: did not find 'apt' nor 'dnf' - exiting"
      exit 6
    fi
  fi
  runCmd sudo systemctl enable mariadb     # set mariadb to start at boot 
 }                                         # instPackages()

#+--------------------------------------------------------------------------+
function mkDirectories
# Create target directories
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  # make 2 CGI dirs, a log file dir and a directory for console data
  echo; echo "Step 3): Creating directories ..." | tee -a $outFile

  mkDir /srv/www/zlma
  mkDir /srv/www/zlmarw
  mkDir /var/log/zlma
  mkDir /srv/consolez

  # set attributes of /var/log/'apache|httpd'
  echo; echo "Step 4): Modifying directory /var/log/$webDir ..." | tee -a $outFile

  cd /var/log
  runCmd sudo chown $webUser.$webUser $webDir
  runCmd sudo chmod 750 httpd
 }                                         # mkDirectories()

#+--------------------------------------------------------------------------+
function copyFiles
# Copy files from repo to target directories
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  # copy all files from CGI dirs in repo to new dirs
  echo; echo "Step 5): Copying CGI files from repo to /srv/www ..." | tee -a $outFile
  copyAllFiles $repoDir/srv/www/zlma   /srv/www/zlma
  copyAllFiles $repoDir/srv/www/zlmarw /srv/www/zlmarw

  # copy files one at a time to /usr/local/sbin
  echo; echo "Step 6): Copying scripts from repo to /usr/local/sbin ..." | tee -a $outFile

  cd $repoDir/usr/local/sbin
  local nextFile
  for nextFile in *; do                    # copy each file to /usr/local/sbin
    copyOneFile $repoDir/usr/local/sbin $nextFile /usr/local/sbin
  done
 }                                         # copyFiles()

#+--------------------------------------------------------------------------+
function mkSymlinks 
# Create symlinks for additional console scripts
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  echo; echo "Step 7): Creating symbolic links ..." | tee -a $outFile

  cd /usr/local/sbin
  if [ ! -h catcons ]; then                # symlink does not exist
    runCmd sudo ln -s spoolcons catcons
  else
    echo "  symlink catcons already exists - skipping"	  
  fi
  if [ ! -h grepcons ]; then
    runCmd sudo ln -s spoolcons grepcons 
  else
    echo "  symlink spoolcons already exists - skipping"	  
  fi
  if [ ! -h lscons ]; then
    runCmd sudo ln -s spoolcons lscons 
  else
    echo "  symlink lscons already exists - skipping"	  
  fi
  if [ ! -h rmcons ]; then
    runCmd sudo ln -s spoolcons rmcons 
  else
    echo "  symlink rmcons already exists - skipping"	  
  fi
}                                          # mkSymlinks() 

#+--------------------------------------------------------------------------+
function mkVenv
# Make a virtual environment under /srv/venv/ 
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  cd /srv/
  echo; echo "Step 8): Creating virtual environment ..." | tee -a $outFile

  runCmd sudo $pythonCmd -m venv venv
  runCmd sudo chown -R $webUser.$webUser /srv/venv 
  runCmd sudo chmod -R g+w /srv/venv 

  echo; echo "Step 9): Activating venv ..." | tee -a $outFile

  runCmd source venv/bin/activate

  echo; echo "Step 10): Upgrading pip ..." | tee -a $outFile

  # runCmd "sudo $pythonCmd -m pip install --upgrade pip"
  runCmd "$pythonCmd -m pip install --upgrade pip"
 }                                         # mkSymlinks()

#+--------------------------------------------------------------------------+
function buildConnector 
# Download and build the mariadb Python connector
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  echo; echo "Step 11): Building and installing the mariadb connector ..." | tee -a $outFile

  if [ -f /usr/local/lib/mariadb/libmariadb.a ]; then
    echo "It appears the mariadb connector is built and installed"
  else                                     # build and install the mariadb connector v3.3.1
    cd                                     # change to home directory
    wget https://downloads.mariadb.org/connector-c/3.3.1/mariadb-connector-c-3.3.1.tar.gz
    tar -xzf mariadb-connector-c-3.3.1.tar.gz
    cd mariadb-connector-c-3.3.1
    runCmd "cmake ."
    runCmd "cmake --build ."
    runCmd "sudo cmake --install ."
  fi
  echo; echo "Step 12): Installing pip packages ..." | tee -a $outFile
  runCmd "sudo $pythonCmd -m pip install certifi charset_normalizer idna mariadb mysql-connector-python packaging ply requests"
 }                                         # buildConnector()

#+--------------------------------------------------------------------------+
function confApache 
# Configure Apache 
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  echo; echo "Step 13): Configuring Apache" | tee -a $outFile

  if [ "$webUser" == "apache" ]; then      # RHEL-based: remove -DFOREGROUND and copy mime.types
    svcFile="/usr/lib/systemd/system/httpd.service"
    if [ ! -f $svcFile.orig ]; then         # no backup
      runCmd sudo cp $svcFile $svcFile.orig # make a backup
      runCmd sudo cp $HOME/zlma/httpd.service.RHEL /usr/lib/systemd/system/httpd.service
      runCmd sudo systemctl daemon-reload   # reload modified file
    fi
    runCmd sudo cp /etc/mime.types /etc/httpd/conf # copy mime.types to Apache conf dir
    runCmd sudo chgrp apache /run/httpd     # change group of run directory
    runCmd sudo chmod 770 /run/httpd        # change mode to group write
  else
    echo "TODO: customize Apache for Debian - NEED AN UBUNTU!!!"
  fi
 }                                         # confApache()

#+--------------------------------------------------------------------------+
function mkCustom 
# fix programs blocking communications such as firewalls and SE Linux 
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  echo; echo "Step 14): Customizing environment ..." | tee -a $outFile

  runCmd sudo cp $HOME/zlma/bash_profile $HOME/.bash_profile
  runCmd sudo mv /etc/vimrc /etc/vimrc.orig                   
  runCmd sudo cp $HOME/zlma/vimrc /etc/                       
 }                                         # mkCustom()

#+--------------------------------------------------------------------------+
function fixBlockers
# fix programs blocking communications such as firewalls and SE Linux
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  echo; echo "Step 15): Opening firewall and turning off SE Linux ..." | tee -a $outFile

  runCmd sudo firewall-cmd --zone=public --add-service=http --permanent # open port 80
  runCmd sudo firewall-cmd --reload        # reload firewall

  if [ -f /etc/selinux/config ]; then      # SE Linux config file exists
    grep "^SELINUX=enforcing" /etc/selinux/config >/dev/null 2>&1
    if [ $? = 0 ]; then                    # SE Linux is enabled
      runCmd sudo sed -e 's/SELINUX=enforcing/SELINUX=disabled/g' -i /etc/selinux/config
      runCmd sudo setenforce 0             # turn SE Linux off for this session
    fi
  fi
 }                                         # fixBlockers()

#+--------------------------------------------------------------------------+
function restartServices
# Restart mariadb and Apache 
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  echo; echo "Step 16): restarting mariadb and Apache ..." | tee -a $outFile

  runCmd sudo systemctl restart mariadb
  if [ "$webUser" == "apache" ]; then      # RHEL-based
    runCmd sudo systemctl start httpd
  else                                     # assume Debian
    runCmd sudo systemctl start apache2
  fi
 }                                         # confApache()

# main()
repoDir="$HOME/zlma"                       # directory with zlma repo 
timeStamp=`date +"%y-%m-%d-%H-%M-%S"`      # current date and time
outFile="$HOME/$timeStamp-instzlma.out"    # log file
pythonCmd="python3"                        # can be another version
verbose=0                                  # 1 = verbose
webDir="unknown"                           # either '/var/log/apache' or '/var/log/httpd'
webUser="unknown"                          # either 'apache' or 'www-data'

parseArgs $@                               # process arguments
checkBase                                  # verify this is s390x
echo "Running instzlma to install zlma at $timeStamp ..." > $outFile # create a new log file
instPackages                               # install packages
mkDirectories                              # make target directories
copyFiles                                  # copy from repo to targets
mkSymlinks                                 # create symlinks in /usr/local/sbin
mkVenv                                     # make a virtual environment
buildConnector                             # create the mariadb Python connector
mkCustom                                   # customize environment and vim settings
fixBlockers                                # fix blockers such as firewall and SE Linux
confApache                                 # set up Apache
restartServices                            # restart mariadb and Apache
let min=$SECONDS/60
let sec=$SECONDS%60
if [ $sec -lt 10 ]; then                   # add a leading 0
  sec="0$sec"
fi
echo
echo "Successfully installed zlma co-reqs in $min:$sec" | tee -a $outFile
echo "Log file: $outFile"

