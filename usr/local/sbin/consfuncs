#!/bin/bash
#
# consfuncs - functions common to consolez
#
#+--------------------------------------------------------------------------+
function verboseMsg
# write a message to stdout when -v|--verbose (2) or -V|--veryverbose (3) are set
# Args: the message to write
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  if [ "$verbose" = 2 ]; then              # verbose
    echo -e "$@"
  elif [ "$verbose" = 3 ]; then            # very verbose
   echo -e "spoolcons: ${FUNCNAME[1]}: $@"
  fi
 }                                         # verboseMsg()

#+--------------------------------------------------------------------------+
function CPcmd
# invoke a CP command with the vmcp module/command
# Args 1-n: the command to issue
# Return:   the CP return code (not the vmcp rc)
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local CPrc=0                             # assume CP command succeeds
  local rc

  verboseMsg "on $thisServer invoking CP command: $vmcpCmd $@"
  CPout=`$vmcpCmd $@ 2>&1`                 # run the CP command
  rc=$?
  if [ "$rc" = 2 ]; then                   # output buffer overflow
    local bytes=`echo $CPout | awk -F'(' '{print $2}' | awk '{print $1}'`
    if [[ "$bytes" -gt 1048576 ]]; then    # output too large
      echo "WARNING: Unable to get CP output of $bytes bytes - larger than 1 MB"
      return 11                            # so caller can exit 11
    fi
    verboseMsg "increasing vmcp buffer size to $bytes bytes and trying again"
    CPout=`$vmcpCmd --buffer=$bytes $@ 2>&1`
    local rc2=$?
    if [ $rc2 != 0 ]; then                 # capture the CP return code after "#"
      CPrc=`echo $CPout | grep "Error: non-zero CP" | awk -F# '{print $2}'`
    fi
  elif [ $rc != 0 ]; then                  # capture the CP return code after "#"
    CPrc=`echo $CPout | grep "Error: non-zero CP" | awk -F# '{print $2}'`
  fi
  if [ ${#CPout} != 0 -a "$CPverbose" != "no" ]; then
    echo "$CPout"                          # show CP output in verbose mode
  fi
  return $CPrc                             # return code from CP
 }                                         # CPcmd()

#+--------------------------------------------------------------------------+
function getEngServer
# Given a z/VM system ID, return the engineering server
# Arg 1: LPAR being queried
# Global variables: 
#   engServer - the engineering server
#   tgtCEC    - the CEC
#   consFile  - saved console file path
#+--------------------------------------------------------------------------+
 {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}

  local theLPAR=$1                         # target z/VM System ID
  if [ ${#theLPAR} = 0 ]; then             # unexpected
    echo "INTERNAL ERROR: no args passed to getEngServer" | tee -a $logFile
    exit 3                                 # internal server error
  fi

  # Assign LPARs and engineering servers to arrays
  lpars=`jq -r '.eng_srvrs[].lpar' /etc/zlma.conf | xargs`         # read engineering servers with jq
  eng_srvrs=`jq -r '.eng_srvrs[].eng_srvr' /etc/zlma.conf | xargs` # read LPARs with jq
  lpars=($lpars)                           # convert to array
  eng_srvrs=($eng_srvrs)                   # convert to array
  numLPARs="${#lpars[@]}"
  local endIndex
  let endIndex=$numLPARs-1
  local i
  for i in `seq 0 $endIndex`; do
    if [ "${lpars[$i]}" = "$theLPAR" ]; then # found LPAR
      echo ${eng_srvrs[$i]}
      return 0                             # success
    fi
  done
  return 1                                 # object not found 
 }                                         # getEngServer()

#+--------------------------------------------------------------------------+
# global variables
sshCmd="/usr/bin/ssh -q"                   # command to SSH to other nodes

